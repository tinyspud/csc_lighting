/******************************************************************************
 *
 * Menu display screen graphics and navigation engine
 * Sets up the menus that are to be shown on the screen.  The contents are
 * controlled by files outside of this
 *
 *
 * MENU vs ITEM
 * Objects are displayed on the UI in one of two ways,
 * as a menu or as an item.
 *
 * Menus allow the user to navigate through them and can be thought of as the
 * roots.  Menus can only display text.
 *
 * Items allow substantially more display flexability and can be thought of as
 * a canvas on which information can be displayed.  Items can display objects,
 * text, figures and other items.
 *
 * Example heigharchy:
 *                A
 *               /|\
 *              / | \
 *             B  C  D
 *            /|\     \
 *           E F G     H
 * A, B, D all have to be menus since they have objects to which they can lead
 * C, E, F, G, H can be either menus or items
 *
 * To register a new menu:
 * void fcn_to_register_menu(){
 *     clear_menu();
 *     set_home(false);
 *     set_back(true, (prevoius menu in available_menu_t enum));
 *
 *     set_screen_title("(Null terminated string)\0");
 *     add_menu_item("(Menu item 1, null terminated string name)\0",
 *         (menu flags), (callback pointer or NULL, see add_menu_item));
 *     (repeat as necessary for all items, current max number of items is
 *     defined in MAX_NUM_MENU_ITEMS)
 * }
 *
 *
 * To register a new menu item:
 * void fcn_to_register_item(){
 *     clear_menu();
 *     set_home(false);
 *     set_back(true, (prevoius menu in available_menu_t enum));
 *
 *     set_screen_title("(Null terminated string)\0");
 *     load_item_render_function((pointer to function, see
 *         load_item_render_function));
 *     (repeat as necessary for however many renderers you need, current max is
 *     defined in MAX_NUM_ITEM_RENDERERS)
 *
 *     (if you want to include a key press handler:)
 *     load_item_key_press_handler((pointer to function, see
 *         load_item_key_press_handler), true/false);
 * }
 *
 *****************************************************************************/

#ifndef __MENU_DISPLAY
#define __MENU_DISPLAY

/* Include the eink and text in this */
#include "eink.h"
#include "vis.h"

/* Graphic icons */
#define GPS_ICON_HEIGHT 37
#define GPS_ICON_WIDTH 5
static const uint8 GPS_ICON[GPS_ICON_HEIGHT][GPS_ICON_WIDTH] = { { 0x00, 0x03,
		0xFE, 0x00, 0x00 }, { 0x00, 0x0F, 0xFF, 0x80, 0x00 }, { 0x00, 0x3F,
		0xB8, 0x60, 0x00 }, { 0x00, 0xFA, 0x30, 0x78, 0x00 }, { 0x01, 0xF7,
		0x00, 0x7C, 0x00 }, { 0x03, 0xFF, 0x80, 0xDE, 0x00 }, { 0x07, 0xFE,
		0x00, 0x7F, 0x00 }, { 0x0F, 0xF0, 0x00, 0x1F, 0x80 }, { 0x1F, 0xE0,
		0x00, 0x7F, 0xC0 }, { 0x1D, 0xC0, 0x00, 0x33, 0xC0 }, { 0x38, 0x80,
		0x00, 0x1E, 0x60 }, { 0x39, 0x00, 0x00, 0x3F, 0xF0 }, { 0x5C, 0x80,
		0x00, 0x7F, 0xF0 }, { 0x4C, 0xA0, 0x00, 0x7F, 0xF0 }, { 0x46, 0x00,
		0x00, 0x7F, 0xF8 }, { 0x86, 0xC0, 0x00, 0x7F, 0xF8 }, { 0x83, 0xF8,
		0x00, 0xFF, 0xF8 }, { 0x81, 0xF8, 0x00, 0x7F, 0xF8 }, { 0x83, 0xFE,
		0x00, 0x57, 0xF8 }, { 0x83, 0xFE, 0x00, 0x01, 0xF8 }, { 0x83, 0xFF,
		0xC0, 0x01, 0xF8 }, { 0x83, 0xFF, 0xC0, 0x01, 0xF8 }, { 0x41, 0xFF,
		0xE0, 0x01, 0xF8 }, { 0x40, 0xFF, 0xC0, 0x01, 0xF0 }, { 0x40, 0xFF,
		0xC0, 0x03, 0xF0 }, { 0x40, 0xFF, 0x80, 0x03, 0xF0 }, { 0x20, 0x7F,
		0x00, 0x03, 0xE0 }, { 0x20, 0xFC, 0x00, 0x07, 0xE0 }, { 0x10, 0x78,
		0x00, 0x03, 0xC0 }, { 0x18, 0x78, 0x00, 0x07, 0x80 }, { 0x0C, 0x70,
		0x00, 0x03, 0x80 }, { 0x04, 0x30, 0x00, 0x01, 0x00 }, { 0x03, 0x30,
		0x00, 0x06, 0x00 }, { 0x01, 0x80, 0x00, 0x0C, 0x00 }, { 0x00, 0x62,
		0x00, 0x30, 0x00 }, { 0x00, 0x1E, 0xA5, 0xC0, 0x00 }, { 0x00, 0x07,
		0xFF, 0x00, 0x00 }, };

#define GSM_ICON_HEIGHT 38
#define GSM_ICON_WIDTH 6

static const uint8 GSM_ICON[GSM_ICON_HEIGHT][GSM_ICON_WIDTH] =
		{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00 },
				{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00 },
				{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00 },
				{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x07,
						0x80, 0x00, 0x00 },
				{ 0x00, 0x00, 0x07, 0x80, 0x00, 0x00 }, { 0x00, 0x00, 0x0F,
						0xC0, 0x00, 0x00 },
				{ 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00 }, { 0x00, 0x00, 0x1F,
						0xE0, 0x00, 0x00 },
				{ 0x00, 0x00, 0x1C, 0xE0, 0x00, 0x00 }, { 0x00, 0x00, 0x3C,
						0xE0, 0x00, 0x00 },
				{ 0x00, 0x00, 0x3F, 0x70, 0x00, 0x00 }, { 0x00, 0x00, 0x3F,
						0xF0, 0x00, 0x00 },
				{ 0x00, 0x00, 0x7F, 0xF8, 0x00, 0x00 }, { 0x00, 0x00, 0x71,
						0xF8, 0x00, 0x00 },
				{ 0x00, 0x00, 0xE0, 0xFC, 0x00, 0x00 }, { 0x00, 0x00, 0xE1,
						0xFC, 0x00, 0x00 },
				{ 0x00, 0x01, 0xC7, 0xFE, 0x00, 0x00 }, { 0x00, 0x01, 0xDF,
						0xCE, 0x00, 0x00 },
				{ 0x00, 0x03, 0xFF, 0x0F, 0x00, 0x00 }, { 0x00, 0x03, 0xFC,
						0x07, 0x00, 0x00 },
				{ 0x00, 0x07, 0xF0, 0x07, 0x80, 0x00 }, { 0x00, 0x07, 0xE0,
						0x03, 0x80, 0x00 },
				{ 0x00, 0x0F, 0xFC, 0x03, 0xC0, 0x00 }, { 0x00, 0x0E, 0xFF,
						0x81, 0xC0, 0x00 },
				{ 0x00, 0x1E, 0x3F, 0xE1, 0xC0, 0x00 }, { 0x00, 0x1C, 0x07,
						0xFC, 0xE0, 0x00 },
				{ 0x00, 0x1C, 0x00, 0xFF, 0xE0, 0x00 }, { 0x00, 0x38, 0x00,
						0x1F, 0xF0, 0x00 },
				{ 0x00, 0x38, 0x00, 0x03, 0xF0, 0x00 }, };

static const uint8 GSM_ICON_WAVES[GSM_ICON_HEIGHT][GSM_ICON_WIDTH] = { { 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x01, 0x00, 0x00, 0x00, 0x02, 0x00 },
		{ 0x03, 0x00, 0x00, 0x00, 0x03, 0x00 }, { 0x07, 0x80, 0x00, 0x00, 0x07,
				0x80 }, { 0x0F, 0x00, 0x00, 0x00, 0x03, 0xC0 }, { 0x0E, 0x00,
				0x00, 0x00, 0x03, 0xC0 },
		{ 0x1E, 0x00, 0x00, 0x00, 0x01, 0xE0 }, { 0x1C, 0x18, 0x00, 0x00, 0xE0,
				0xE0 }, { 0x3C, 0x1C, 0x00, 0x00, 0xE0, 0xE0 }, { 0x38, 0x3C,
				0x00, 0x00, 0xF0, 0x70 },
		{ 0x38, 0x38, 0x00, 0x00, 0x70, 0x70 }, { 0x38, 0x78, 0x00, 0x00, 0x70,
				0x70 }, { 0x38, 0x70, 0x00, 0x00, 0x38, 0x70 }, { 0x38, 0x70,
				0x00, 0x00, 0x38, 0x70 },
		{ 0x38, 0x70, 0x00, 0x00, 0x38, 0x70 }, { 0x38, 0x70, 0x00, 0x00, 0x38,
				0x70 }, { 0x38, 0x70, 0x00, 0x00, 0x78, 0x70 }, { 0x38, 0x38,
				0x00, 0x00, 0x70, 0x70 },
		{ 0x38, 0x38, 0x00, 0x00, 0x70, 0x70 }, { 0x38, 0x3C, 0x00, 0x00, 0xE0,
				0xF0 }, { 0x1C, 0x1C, 0x00, 0x00, 0xE0, 0xE0 }, { 0x1C, 0x08,
				0x00, 0x00, 0x40, 0xE0 },
		{ 0x1E, 0x00, 0x00, 0x00, 0x01, 0xC0 }, { 0x0F, 0x00, 0x00, 0x00, 0x03,
				0xC0 }, { 0x07, 0x00, 0x00, 0x00, 0x03, 0x80 }, { 0x07, 0x80,
				0x00, 0x00, 0x07, 0x80 },
		{ 0x03, 0x00, 0x00, 0x00, 0x03, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00 }, };

#define UP_ARROW_WIDTH 4
#define UP_ARROW_HEIGHT 13

static const uint8 UP_ARROW[UP_ARROW_HEIGHT][UP_ARROW_WIDTH] = { { 0x00, 0x0C,
		0x00, 0x00 }, { 0x00, 0x1E, 0x00, 0x00 }, { 0x00, 0x3F, 0x00, 0x00 }, {
		0x00, 0x7F, 0x80, 0x00 }, { 0x00, 0xFF, 0xC0, 0x00 }, { 0x01, 0xFF,
		0xE0, 0x00 }, { 0x03, 0xFF, 0xF0, 0x00 }, { 0x07, 0xFF, 0xF8, 0x00 }, {
		0x0F, 0xFF, 0xFC, 0x00 }, { 0x1F, 0xFF, 0xFE, 0x00 }, { 0x3F, 0xFF,
		0xFF, 0x00 }, { 0x7F, 0xFF, 0xFF, 0x80 }, { 0xFF, 0xFF, 0xFF, 0xC0 }, };

#define HOME_WIDTH 4
#define HOME_HEIGHT 24

static const uint8 HOME_ICON[HOME_HEIGHT][HOME_WIDTH] = { { 0x00, 0x00, 0x00,
		0x00 }, { 0x00, 0x00, 0x38, 0x00 }, { 0x00, 0x00, 0x38, 0x00 }, { 0x00,
		0x06, 0x38, 0x00 }, { 0x00, 0x0F, 0xB8, 0x00 },
		{ 0x00, 0x3F, 0xF8, 0x00 }, { 0x00, 0xFF, 0xF8, 0x00 }, { 0x03, 0xFF,
				0xFC, 0x00 }, { 0x07, 0xFF, 0xFF, 0x00 }, { 0x1F, 0xFF, 0xFF,
				0x80 }, { 0x7F, 0xFF, 0xFF, 0xE0 }, { 0x01, 0xFF, 0xFC, 0x00 },
		{ 0x01, 0xFF, 0xFC, 0x00 }, { 0x01, 0xFF, 0xFC, 0x00 }, { 0x01, 0xF0,
				0x7C, 0x00 }, { 0x01, 0xF8, 0x7C, 0x00 }, { 0x01, 0xFE, 0x7C,
				0x00 }, { 0x01, 0xFF, 0x7C, 0x00 }, { 0x01, 0xFF, 0x7C, 0x00 },
		{ 0x01, 0xFF, 0x7C, 0x00 }, { 0x01, 0xFF, 0x7C, 0x00 }, { 0x01, 0xFF,
				0x7C, 0x00 }, { 0x00, 0x0F, 0x00, 0x00 }, { 0x00, 0x07, 0x00,
				0x00 }, };

#define RETURN_ARROW_WIDTH 3
#define RETURN_ARROW_HEIGHT 15

static const uint8 RETURN_ARROW[RETURN_ARROW_HEIGHT][RETURN_ARROW_WIDTH] =
		{ { 0x00, 0x00, 0x3C }, { 0x00, 0x00, 0x3C }, { 0x00, 0x00, 0x3C }, {
				0x00, 0x00, 0x3C }, { 0x00, 0x00, 0x3C }, { 0x00, 0x00, 0x3C },
				{ 0x02, 0x00, 0x3C }, { 0x06, 0x00, 0x7C },
				{ 0x0F, 0xFF, 0xFC }, { 0x1F, 0xFF, 0xFC },
				{ 0x3F, 0xFF, 0xFC }, { 0x1F, 0xFF, 0xFC },
				{ 0x0F, 0xFF, 0xF8 }, { 0x06, 0x00, 0x00 }, { 0x02, 0x00, 0x00 }, };

/* Spacing parameters */
/* Space between items (vertical) */
#define MENU_VERT_SPACE	(RENDER_KERN_PIXELS)
/* Starting row of the text for the menu */
#define MENU_TOP_BUFF	(MENU_VERT_SPACE + 5)
/* Height of one item */
#define ITEM_HEIGHT	(__HELV_HEIGHT + MENU_VERT_SPACE)
/* Height of the title bar */
#define MENU_TITLE_HEIGHT (ITEM_HEIGHT + (2 * MENU_VERT_SPACE) + 2)
/* Height of the house icon + some spacing (house icon is the tallest icon on the bottom) */
#define MENU_BOTTOM_HEIGHT (HOME_HEIGHT + MENU_VERT_SPACE)
/* Calculate the number of items you can fit onto a screen */
#define NUM_ITEMS_FULLY_VISIBLE ((LINES_ON_SCREEN - (MENU_BOTTOM_HEIGHT + MENU_TITLE_HEIGHT)) / ITEM_HEIGHT)

#define MENU_BAR_WIDTH		5
#define MENU_RIGHT_BAR_LINE	((8 * BYTES_IN_1_LINE) - MENU_BAR_WIDTH)

#define MENU_ACTIVE_HEIGHT	(LINES_ON_SCREEN - (MENU_TITLE_HEIGHT + MENU_BOTTOM_HEIGHT))
#define MENU_ITEM_MOVE_SPACE	(MENU_ACTIVE_HEIGHT * 0.8)

/* Maximum number of entries in a single menu (arbitrarily defined value, can
 * increase if necessary though it makes the key mapping more interesting)
 * NOTE - item 10 (index 9) is accessed by key 0 in this scheme
 * */
#define MAX_NUM_MENU_ITEMS 10

/* Menu item flags */
#define MENU_FLAG_ITEM_DISABLE	0x01

/* Manually tuned value */
#define MENU_HORIZ_OFFET (35)

/* Max string size for title */
#define MENU_TITLE_MAX_STRING_LENGTH 25
/* Max string size for each menu item */
#define MENU_ITEM_MAX_STRING_LENGTH 130

#define MENU_ITEM_MAX_HEIGHT	(4 * LINES_ON_SCREEN)
#define MAX_NUM_ITEM_RENDERERS	10

/* Max length of an emergency message */
#define EMCY_MSG_MAX_LENGTH	300

/* Callback prototype for menu items:
 * Inputs:
 * None
 *
 * Outputs:
 * Boolean  | True if no further drawing is required
 *          | False if should be passed and needs further processing
 *          | by functions down the line
 *          | (i. e. further drawing, etc.)
 *  */
typedef boolean (*menuItemCallbackFunctionPtrType)(void);

/* Render prototype for menu items:
 * Inputs:
 * None
 *
 * Outputs:
 * int     | Bottommost pixel desired (used for displaying) - if this value is
 *         | less than or equal to 0, it will auto calculate it within the menu
 *         | rendering function.
 *  */
typedef int (*menuItemRenderFunctionPtrType)(void);

/* Item input prototype for menu items:
 * Inputs:
 * Key pad state
 *
 * Outputs:
 * boolean   | TRUE: redraw the screen (calls the menuItemRenderFunctions
 *           | loaded with the item, unless the screen is switched in this
 *           | function in which case the screen is redrawn using the new
 *           | screen's draw functions)
 *           | FALSE: Receives the data, does not say to redraw the screen
 *
 * NOTE:
 * Keys accepted by this function will only be key states that do NOT include
 * the navigation keys (A-D) since the menu will automatically handle
 * navigation keys UNLESS the l_item_needs_complete_keypad_control flag is set
 * to true in which case this has to handle ALL key presses (flag is set when
 * the function is loaded into the menu)
 *  */
typedef boolean (*menuItemKeyPressFunctionPtrType)(uint16_t);

#define POSITION_A	50
#define POSITION_B	150
#define POSITION_C	250
#define POSITION_D	350

#define ITEM_RENDER_SPACE_HEIGHT	MENU_ITEM_MAX_HEIGHT
#define ITEM_RENDER_SPACE_WIDTH		(BYTES_IN_1_LINE)

extern uint8 g_item_render_space[ITEM_RENDER_SPACE_HEIGHT][ITEM_RENDER_SPACE_WIDTH];

extern boolean g_gps_is_set;
extern boolean g_gsm_is_set;
extern boolean g_is_home;
extern boolean g_can_go_back;

void draw_top_info(void);

void draw_bottom_info_MENU(void);

void render_menu(void);

int get_menu_item_vert_offset(int);

int get_menu_item_vert_offset_for_rendering(int);

void clear_menu(void);

int get_last_index_value(void);

void set_screen_title(char*);

void add_menu_item(char*, uint8, menuItemCallbackFunctionPtrType);

void load_item_render_function(menuItemRenderFunctionPtrType);

void load_item_key_press_handler(menuItemKeyPressFunctionPtrType, boolean);

boolean is_key_pressed_navigation(uint16);

boolean menu_up(void);

boolean menu_down(void);

boolean menu_home(void);

boolean menu_back(void);

boolean item_up();

boolean item_down();

boolean item_home(void);

boolean item_back(void);

void menu_driver_init(void);

void set_gps(boolean);

void set_gsm(boolean);

void set_home(boolean);

void set_back_low_level(boolean);

void process_keypress(uint16_t);

boolean select_menu_item(uint16_t);

void draw_arrow(int, int, uint8_t, boolean);

void draw_home(int, int, uint8_t);

void draw_return_arrow(int, int, uint8_t);

void draw_home_icon(void);

void draw_back_icon(void);

boolean generic_menu_item_selector(int);

void pre_render_menu_item();

void try_draw_menu_now();

void clear_render_space();

#endif

